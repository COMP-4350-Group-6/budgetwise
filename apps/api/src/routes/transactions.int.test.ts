import { describe, it, expect } from 'vitest';
import { app } from '../app';

interface CategoryCreateResponse {
  category: {
    id: string;
    name: string;
    isActive: boolean;
    isDefault: boolean;
  };
}

interface BudgetCreateResponse {
  budget: {
    id: string;
    categoryId: string;
    name: string;
    amountCents: number;
    currency: string;
    period: string;
    startDate: string;
    endDate?: string;
    isActive: boolean;
  };
}

interface DashboardResponse {
  dashboard: {
    categories: Array<{
      categoryId: string;
      totalBudgetCents: number;
      totalSpentCents: number;
      totalRemainingCents: number;
      budgets: Array<{
        budget: { id: string; amountCents: number };
        spentCents: number;
      }>;
    }>;
    totalBudgetCents: number;
    totalSpentCents: number;
  };
}

async function parseJson<T>(res: Response): Promise<T> {
  return (await res.json()) as T;
}

describe('Integration: Category + Budget + Transaction -> Dashboard', () => {
  const authToken = 'test-token';        // matches existing tests
  const userId = 'test-user-123';        // body-provided for /transactions (no auth middleware there)

  it('should reflect added transaction in dashboard totals', async () => {
    // 1) Create category
    const catRes = await app.request('/categories', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ name: 'Groceries', isActive: true }),
    });
    expect(catRes.status).toBe(201);
    const catData = await parseJson<CategoryCreateResponse>(catRes);
    const categoryId = catData.category.id;

    // 2) Create budget for category
    const budgetRes = await app.request('/budgets', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        categoryId,
        name: 'Monthly Groceries',
        amountCents: 50000,
        currency: 'CAD',
        period: 'MONTHLY',
        startDate: '2025-01-01',
      }),
    });
    expect(budgetRes.status).toBe(201);
    const budgetData = await parseJson<BudgetCreateResponse>(budgetRes);
    const budgetId = budgetData.budget.id;

    // 3) Add transaction against this budget (transactions route does not use auth middleware; provide userId in body)
    const txRes = await app.request('/transactions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        // TransactionDTO enforces id/userId/createdAt/updatedAt, but the handler ignores id/timestamps
        // We supply userId; id/timestamps are generated by usecase. If schema enforces, we can pass dummy values.
        id: '01HZYTESTTRANSACTION0000000001', // satisfies z.ulid() if needed; value shape is ULID-like
        userId,
        budgetId,
        amountCents: 42500,
        categoryId,                 // optional; budget linkage drives aggregation
        note: 'Grocery spend',
        occurredAt: new Date('2025-01-15').toISOString(),
        createdAt: new Date('2025-01-15').toISOString(),
        updatedAt: new Date('2025-01-15').toISOString(),
      }),
    });
    expect(txRes.status).toBe(201);

    // 4) Read dashboard and assert category totals decreased by transaction amount
    const dashRes = await app.request('/budgets/dashboard', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`,
      },
    });
    expect(dashRes.status).toBe(200);
    const dash = await parseJson<DashboardResponse>(dashRes);

    // Find our category summary
    const catSummary = dash.dashboard.categories.find(c => c.categoryId === categoryId);
    expect(catSummary).toBeDefined();
    expect(catSummary!.totalBudgetCents).toBe(50000);
    expect(catSummary!.totalSpentCents).toBe(42500);
    expect(catSummary!.totalRemainingCents).toBe(50000 - 42500);

    // Budget-level status should reflect spend too
    const budgetStatus = catSummary!.budgets.find(b => b.budget.id === budgetId);
    expect(budgetStatus).toBeDefined();
    expect(budgetStatus!.spentCents).toBe(42500);

    // Dashboard aggregate totals
    expect(dash.dashboard.totalBudgetCents).toBeGreaterThan(0);
    expect(dash.dashboard.totalSpentCents).toBeGreaterThan(0);
  });
});