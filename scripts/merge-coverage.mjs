#!/usr/bin/env node

/**
 * Merge Coverage Script
 * 
 * This script merges coverage reports from all packages in the monorepo
 * into a single unified coverage report at the repository root.
 * 
 * It uses the lcov.info files generated by Vitest's v8 coverage provider.
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync, statSync } from 'fs';
import { join, relative } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = join(__dirname, '..');

// Packages and apps to collect coverage from
const COVERAGE_SOURCES = [
  'apps/api',
  'apps/frontend/auth',
  'apps/frontend/web-next',
  'packages/adapters/auth-supabase',
  'packages/adapters/persistence/local',
  'packages/adapters/persistence/supabase',
  'packages/adapters/services/openrouter',
  'packages/adapters/system',
  'packages/domain',
  'packages/usecases',
];

// CI artifact directories (when running in GitHub Actions)
const CI_COVERAGE_SOURCES = [
  'coverage-temp/unit',
  'coverage-temp/integration',
];

/**
 * Find all lcov.info files recursively in a directory
 */
function findLcovFiles(dir) {
  const lcovFiles = [];
  
  if (!existsSync(dir)) {
    return lcovFiles;
  }

  const files = readdirSync(dir);
  
  for (const file of files) {
    const fullPath = join(dir, file);
    const stat = statSync(fullPath);
    
    if (stat.isDirectory()) {
      lcovFiles.push(...findLcovFiles(fullPath));
    } else if (file === 'lcov.info') {
      lcovFiles.push(fullPath);
    }
  }
  
  return lcovFiles;
}

/**
 * Adjust file paths in lcov data to be relative to repo root
 */
function adjustLcovPaths(lcovContent, packagePath) {
  const lines = lcovContent.split('\n');
  const adjustedLines = [];
  
  for (const line of lines) {
    if (line.startsWith('SF:')) {
      // Extract the file path
      const filePath = line.substring(3);
      
      // If path is already absolute or starts with package name, keep it
      if (filePath.startsWith('/') || filePath.startsWith('apps/') || filePath.startsWith('packages/')) {
        adjustedLines.push(line);
      } else {
        // Make path relative to repo root
        const adjustedPath = join(packagePath, filePath);
        adjustedLines.push(`SF:${adjustedPath}`);
      }
    } else {
      adjustedLines.push(line);
    }
  }
  
  return adjustedLines.join('\n');
}

/**
 * Main function to merge all coverage reports
 */
function mergeCoverage() {
  console.log('üîç Searching for coverage reports...\n');
  
  let allLcovContent = [];
  let totalFiles = 0;
  
  // Check CI artifact directories first (GitHub Actions)
  for (const source of CI_COVERAGE_SOURCES) {
    const sourcePath = join(ROOT_DIR, source);
    const lcovFiles = findLcovFiles(sourcePath);
    
    for (const lcovFile of lcovFiles) {
      try {
        const content = readFileSync(lcovFile, 'utf-8');
        // CI artifacts should already have correct paths
        allLcovContent.push(content);
        totalFiles++;
        console.log(`‚úÖ Processed CI artifact: ${relative(ROOT_DIR, lcovFile)}`);
      } catch (error) {
        console.error(`‚ùå Error reading CI artifact ${lcovFile}:`, error.message);
      }
    }
  }
  
  // Check local package coverage directories
  for (const source of COVERAGE_SOURCES) {
    const sourcePath = join(ROOT_DIR, source);
    const coveragePath = join(sourcePath, 'coverage');
    
    if (!existsSync(coveragePath)) {
      console.log(`‚è≠Ô∏è  Skipping ${source} (no coverage directory)`);
      continue;
    }
    
    const lcovFiles = findLcovFiles(coveragePath);
    
    if (lcovFiles.length === 0) {
      console.log(`‚è≠Ô∏è  Skipping ${source} (no lcov.info found)`);
      continue;
    }
    
    for (const lcovFile of lcovFiles) {
      try {
        const content = readFileSync(lcovFile, 'utf-8');
        const adjustedContent = adjustLcovPaths(content, source);
        allLcovContent.push(adjustedContent);
        totalFiles++;
        console.log(`‚úÖ Processed: ${relative(ROOT_DIR, lcovFile)}`);
      } catch (error) {
        console.error(`‚ùå Error reading ${lcovFile}:`, error.message);
      }
    }
  }
  
  if (totalFiles === 0) {
    console.log('\n‚ö†Ô∏è  No coverage reports found. Run tests with coverage first:');
    console.log('   pnpm test:coverage\n');
    return;
  }
  
  // Create merged coverage directory
  const mergedCoverageDir = join(ROOT_DIR, 'course-work', 'coverage-report-full');
  if (!existsSync(mergedCoverageDir)) {
    mkdirSync(mergedCoverageDir, { recursive: true });
  }
  
  // Write merged lcov file
  const mergedLcovPath = join(mergedCoverageDir, 'lcov.info');
  const mergedContent = allLcovContent.join('\n');
  writeFileSync(mergedLcovPath, mergedContent);
  
  console.log(`\n‚ú® Merged ${totalFiles} coverage reports`);
  console.log(`üìä Output: ${relative(ROOT_DIR, mergedLcovPath)}`);
  console.log('\nüí° To generate HTML report, run:');
  console.log('   genhtml course-work/coverage-report-full/lcov.info -o course-work/coverage-report-full/html');
  console.log('   (Note: genhtml requires lcov to be installed: sudo apt-get install lcov)');
  console.log('\nüí° To view the HTML report:');
  console.log('   xdg-open course-work/coverage-report-full/html/index.html\n');
}

// Run the merge
mergeCoverage();
